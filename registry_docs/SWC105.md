#### 无保护的以太币提现
CWE-284:访问控制不当

#### 描述
由于访问控制缺失或不足，恶意方可以从合约账户中提取部分或全部以太币。

此错误有时是由无意暴露初始化函数引起的。 通过错误地命名一个打算作为构造函数的函数，构造函数代码最终会出现在运行时字节码中，并且可以被任何人调用以重新初始化合约。

#### 矫正方法
实施控制，使提款只能由授权方或根据智能合约系统的规范触发。

#### Contract Samples
multiowned_not_vulnerable.sol

```
pragma solidity ^0.4.23;

/**
 * @title MultiOwnable
 */
contract MultiOwnable {
  address public root;
  mapping (address => address) public owners; // owner => parent of owner
  
  /**
  * @dev The Ownable constructor sets the original `owner` of the contract to the sender
  * account.
  */
  constructor() public {
    root = msg.sender;
    owners[root] = root;
  }
  
  /**
  * @dev Throws if called by any account other than the owner.
  */
  modifier onlyOwner() {
    require(owners[msg.sender] != 0);
    _;
  }
  
  /**
  * @dev Adding new owners
  * Note that the "onlyOwner" modifier is missing here.
  */ 
  function newOwner(address _owner) onlyOwner external returns (bool) {
    require(_owner != 0);
    owners[_owner] = msg.sender;
    return true;
  }
  
  /**
    * @dev Deleting owners
    */
  function deleteOwner(address _owner) onlyOwner external returns (bool) {
    require(owners[_owner] == msg.sender || (owners[_owner] != 0 && msg.sender == root));
    owners[_owner] = 0;
    return true;
  }
}

contract TestContract is MultiOwnable {
  
  function withdrawAll() onlyOwner {
    msg.sender.transfer(this.balance);
  }

  function() payable {
  }

}
```
multiowned_not_vulnerable.yaml

```
description: Ether withdrawal function and correclty named constructor (not vulnerable)
issues:
- id: SWC-105
  count: 0
  locations: []
```
multiowned_vulnerable.sol

```
pragma solidity ^0.4.23;

/**
 * @title MultiOwnable
 */
contract MultiOwnable {
  address public root;
  mapping (address => address) public owners; // owner => parent of owner
  
  /**
  * @dev The Ownable constructor sets the original `owner` of the contract to the sender
  * account.
  */
  constructor() public {
    root = msg.sender;
    owners[root] = root;
  }
  
  /**
  * @dev Throws if called by any account other than the owner.
  */
  modifier onlyOwner() {
    require(owners[msg.sender] != 0);
    _;
  }
  
  /**
  * @dev Adding new owners
  * Note that the "onlyOwner" modifier is missing here.
  */ 
  function newOwner(address _owner) external returns (bool) {
    require(_owner != 0);
    owners[_owner] = msg.sender;
    return true;
  }
  
  /**
    * @dev Deleting owners
    */
  function deleteOwner(address _owner) onlyOwner external returns (bool) {
    require(owners[_owner] == msg.sender || (owners[_owner] != 0 && msg.sender == root));
    owners[_owner] = 0;
    return true;
  }
}

contract TestContract is MultiOwnable {
  
  function withdrawAll() onlyOwner {
    msg.sender.transfer(this.balance);
  }

  function() payable {
  }

}

```
multiowned_vulnerable.yaml

```
description: newOwner no access control
issues:
- id: SWC-105
  count: 1
  locations:
  - bytecode_offsets:
      '0xce9067a8af4d3e76199016c5659d2acdb76482119264e27e59fdf62af40446a9': [789]
    line_numbers:
      multiowned_vulnerable.sol: [31]
```
simple_ether_drain.sol

```
pragma solidity ^0.4.22;

contract SimpleEtherDrain {

  function withdrawAllAnyone() {
    msg.sender.transfer(this.balance);
  }

  function () public payable {
  }

}
```
simple_ether_drain.yaml

```
description: Anybody can withdraw all Ether from the contract account
issues:
- id: SWC-105
  count: 1
  locations:
  - bytecode_offsets:
      '0x5248a28372021da3b9c50296322a90720938e40e72299d8d93d9c48756ad809a': [156]
    line_numbers:
      simple_ether_drain.sol: [6]
```
wallet_01_ok.sol

```
pragma solidity ^0.4.24;

/* User can add pay in and withdraw Ether.
   Nobody can withdraw more Ether than they paid in.
*/

contract Wallet {
    address creator;
    
    mapping(address => uint256) balances;

    constructor() public {
        creator = msg.sender;
    }

    function deposit() public payable {
        assert(balances[msg.sender] + msg.value > balances[msg.sender]);
        balances[msg.sender] += msg.value;
    }
    
    function withdraw(uint256 amount) public {
        require(amount <= balances[msg.sender]);
        msg.sender.transfer(amount);
        balances[msg.sender] -= amount;
    }

    function refund() public {
        msg.sender.transfer(balances[msg.sender]);
        balances[msg.sender] = 0;
    }
}
```
wallet_01_ok.yaml

```
description: User can withdraw Ether, but not more than they paid in
issues:
- id: SWC-105
  count: 0
  locations: []
```
wallet_02_refund_nosub.sol

```
pragma solidity ^0.4.24;

/* User can add pay in and withdraw Ether.
   Unfortunately the developer forgot set the user's balance to 0 when refund() is called.
   An attacker can pay in a small amount of Ether and call refund() repeatedly to empty the contract.
*/

contract Wallet {
    address creator;
    
    mapping(address => uint256) balances;

    constructor() public {
        creator = msg.sender;
    }

    function deposit() public payable {
        assert(balances[msg.sender] + msg.value > balances[msg.sender]);
        balances[msg.sender] += msg.value;
    }
    
    function withdraw(uint256 amount) public {
        require(amount <= balances[msg.sender]);
        msg.sender.transfer(amount);
        balances[msg.sender] -= amount;
    }

    function refund() public {
        msg.sender.transfer(balances[msg.sender]);
    }
    
    function migrateTo(address to) public {
        require(creator == msg.sender);
        to.transfer(this.balance);
    }
}
```
wallet_02_refund_nosub.yaml

```
description: refund逻辑并没有对用户余额清零，攻击者可以反复调用refund()来清空合约
function refund() public {
        msg.sender.transfer(balances[msg.sender]);
}
```
wallet_03_wrong_constructor.sol

```
pragma solidity ^0.4.24;

/* User can add pay in and withdraw Ether.
   The constructor is wrongly named, so anyone can become 'creator' and withdraw all funds.
*/

contract Wallet {
    address creator;
    
    mapping(address => uint256) balances;

    function initWallet() public {
        creator = msg.sender;
    }

    function deposit() public payable {
        assert(balances[msg.sender] + msg.value > balances[msg.sender]);
        balances[msg.sender] += msg.value;
    }
    
    function withdraw(uint256 amount) public {
        require(amount <= balances[msg.sender]);
        msg.sender.transfer(amount);
        balances[msg.sender] -= amount;
    }
    
    function migrateTo(address to) public {
        require(creator == msg.sender);
        to.transfer(this.balance);
    }
}

```
description：
攻击者可以通过调用 initWallet() 成为“创建者”并提取所有资金

wallet_04_confused_sign.sol

```
pragma solidity ^0.4.24;

/* User can add pay in and withdraw Ether.
   Unfortunatelty, the developer was drunk and used the wrong comparison operator in "withdraw()"
   Anybody can withdraw arbitrary amounts of Ether :()
*/

contract Wallet {
    address creator;
    
    mapping(address => uint256) balances;

    constructor() public {
        creator = msg.sender;
    }

    function deposit() public payable {
        assert(balances[msg.sender] + msg.value > balances[msg.sender]);
        balances[msg.sender] += msg.value;
    }
    
    function withdraw(uint256 amount) public {
        require(amount >= balances[msg.sender]);
        msg.sender.transfer(amount);
        balances[msg.sender] -= amount;
    }

    // In an emergency the owner can migrate  allfunds to a different address.

    function migrateTo(address to) public {
        require(creator == msg.sender);
        to.transfer(this.balance);
    }

}
```
description：
由于withdraw function中的错误比较运算符(应该使用<)，攻击者可以提取无限资金