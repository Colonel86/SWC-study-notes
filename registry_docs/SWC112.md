## 将呼叫委托给不受信任的被呼叫者

#### Relationships
[CWE-829: 包含不受信任的控制领域的功能](https://cwe.mitre.org/data/definitions/829.html)

#### Description
存在一个消息调用的特殊变体，名为`delegatecall`，它与消息调用相同，除了目标地址的代码在调用合约的上下文中执行并且`msg.sender`和`msg.value`不变 他们的价值观。 这允许智能合约在运行时从不同地址动态加载代码。 **存储、当前地址和余额仍以调用合约为准**。

调用不受信任的合约是非常危险的，因为目标地址的代码可以更改调用者的任何存储值，并且可以完全控制调用者的余额。


#### Remediation
谨慎使用`delegatecall`，并确保永远不要调用不受信任的合约。 如果目标地址来自用户输入，请确保根据可信合约的白名单对其进行检查。

#### References
- [Solidity Documentation - Delegatecall / Callcode and Libraries](https://solidity.readthedocs.io/en/latest/introduction-to-smart-contracts.html#delegatecall-callcode-and-libraries)
- [How to Secure Your Smart Contracts: 6 Solidity Vulnerabilities and how to avoid them (Part 1) - Delegate Call](https://medium.com/loom-network/how-to-secure-your-smart-contracts-6-solidity-vulnerabilities-and-how-to-avoid-them-part-1-c33048d4d17d)
- [Solidity Security: Comprehensive list of known attack vectors and common anti-patterns - Delegatecall](https://blog.sigmaprime.io/solidity-security.html#delegatecall)

#### Contract Samples
##### proxy.sol
```
pragma solidity ^0.4.24;

contract Proxy {

  address owner;

  constructor() public {
    owner = msg.sender;  
  }

  function forward(address callee, bytes _data) public {
    require(callee.delegatecall(_data));
  }

}
```
**问题描述**：带委托调用的简单代理模式
**解决方案**：
确定委托调用的合约是安全的，由owner来控制可调用的合约
```
pragma solidity ^0.4.24;

contract Proxy {

  address callee;
  address owner;

  modifier onlyOwner {
    require(msg.sender == owner);
    _;
  }

  constructor() public {
    callee = address(0x0);
    owner = msg.sender;
  }

  function setCallee(address newCallee) public onlyOwner {
    callee = newCallee;
  }

  function forward(bytes _data) public {
    require(callee.delegatecall(_data));
  }

}
```

##### proxy_pattern_false_positive.sol
```
pragma solidity ^0.4.24;

contract proxy{
  address owner;

  function proxyCall(address _to, bytes _data) external {
    require( !_to.delegatecall(_data));
  }
  function withdraw() external{
    require(msg.sender == owner);
    msg.sender.transfer(address(this).balance);
  }
} 

/*
You can't use proxyCall to change the owner address as either: 

1) the delegatecall reverts and thus does not change owner
2) the delegatecall does not revert and therefore will cause the proxyCall to revert and preventing owner from changing

This false positive may seem like a really edge case, however since you can revert data back to proxy this patern is useful for proxy architectures
*/
```
将调用委托给永远不会改变状态的任意地址：
1. delegatecall revert，那么就表明委托者不会改变任何状态，包括当前合约的owner
2. delegatecall 不 revert(委托合约可以执行成功)，会导致 proxyCall revert，并阻止当前合约的所有状态改变，包括owner。

> 这里要试下delegatecall 不revert，委托合约可以改变委托合约的状态，但是不能改变代理合约的状态