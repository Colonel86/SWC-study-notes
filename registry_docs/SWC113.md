## 呼叫失败的 DoS

#### Relationships
[CWE-703: Improper Check or Handling of Exceptional Conditions](https://cwe.mitre.org/data/definitions/703.html)(异常情况检查或处理不当)

#### Description
外部调用可能会意外或故意失败，这可能会导致合约中出现 DoS 条件。 为了尽量减少此类故障造成的损害，最好将每个外部调用隔离到其自己的事务中，该事务可由调用的接收者发起。 这与支付尤其相关，最好让用户提取资金而不是自动向他们推送资金（这也减少了气体限制问题的可能性）。

#### Remediation
建议遵循call最佳实践：

- 避免在单个事务中组合多个调用，尤其是当调用作为循环的一部分执行时
- 总是假设外部调用可能会失败
- 实现合约逻辑来处理失败的调用

#### References
[ConsenSys Smart Contract Best Practices](https://consensys.github.io/smart-contract-best-practices/recommendations/#favor-pull-over-push-for-external-calls)

### Contract Samples
#### send_loop.sol
```
/*
 * @source: https://consensys.github.io/smart-contract-best-practices/known_attacks/#dos-with-unexpected-revert
 * @author: ConsenSys Diligence
 * Modified by Bernhard Mueller
 */

pragma solidity 0.4.24;

contract Refunder {
    
address[] private refundAddresses;
mapping (address => uint) public refunds;

    constructor() {
        refundAddresses.push(0x79B483371E87d664cd39491b5F06250165e4b184);
        refundAddresses.push(0x79B483371E87d664cd39491b5F06250165e4b185);
    }

    // bad
    function refundAll() public {
        for(uint x; x < refundAddresses.length; x++) { // 基于参与的地址数量的任意长度迭代
            require(refundAddresses[x].send(refunds[refundAddresses[x]])); // 更糟糕的是，现在一次发送失败将占用所有资金 ???
        }
    }

}
```
**问题描述**
在循环中调用send
1. 如果refundAddresses地址太多，将会导致refundAll()消耗的gas超过block的gaslimit
2. 没有判断refunds[refundAddresses[x]]状态，也没有更改refunds[refundAddresses[x]]状态
3. 如果第一个地址发送始终失败，那么从第二个地址以后的refund就提取不出来了