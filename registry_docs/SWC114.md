## 交易顺序依赖

#### Relationships
[CWE-362: Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')](https://cwe.mitre.org/data/definitions/362.html)(使用不正确同步的共享资源并发执行（“竞争条件”）)

#### Description
以太坊网络以块为单位处理交易，新块大约每 17 秒得到一次确认。 矿工查看他们收到的交易，并根据谁支付了足够高的汽油价格来选择将哪些交易包含在一个区块中。 此外，当交易被发送到以太坊网络时，它们会被转发到每个节点进行处理。 因此，运行以太坊节点的人可以在最终确定之前知道哪些交易将发生。当代码依赖于提交给它的交易的顺序时，就会出现竞争条件漏洞。

竞争条件的最简单示例是智能合约对提交信息给予奖励。 假设合约将向第一个解决数学问题的人发放 1 个代币。 Alice 解决了这个问题，并以标准的 gas 价格将答案提交给网络。 Eve 运行一个以太坊节点，并且可以在 Alice 提交给网络的交易中看到数学问题的答案。 因此 Eve 以更高的 gas 价格将答案提交给网络，因此它在 Alice 的交易之前得到处理和提交。 Eve收到一个令牌，而Alice一无所获，即使是Alice努力解决问题。 在实践中发生这种情况的一种常见方式是，当合同通过将不良行为者的押金提供给证明他们行为不端的人来奖励人们在协议中指出不良行为时。

今天网络上发生最多的竞态条件是 ERC20 代币标准中的竞态条件。 ERC20 代币标准包括一个名为“approve”的功能，它允许一个地址approve另一个地址代表他们使用代币。 假设 Alice 已经approve Eve 花费她的 n 个代币，那么 Alice 决定将 Eve 的approve改为 m 个代币。 Alice 使用 Eve 的值 n 提交一个函数调用来approve。 Eve 运行一个以太坊节点，因此知道 Alice 会将她的approve更改为 m。 然后 Eve 提交了一个 tranferFrom 请求，将 Alice 的 n 个代币发送给她自己，但给它的 gas 价格比 Alice 的交易高得多。 transferFrom 首先执行，因此给 Eve n 个令牌并将 Eve 的approve设置为零。 然后 Alice 的交易执行并将 Eve 的approve设置为 m。 然后 Eve 也将这 m 个令牌发送给她自己。 因此，Eve 得到了 n + m 个令牌，甚至认为她最多应该得到 max(n,m)。

#### Remediation
在提交信息以换取奖励时，一种可能的补救竞争条件的方法称为提交揭示哈希方案。有答案的一方没有提交答案，而是提交了 hash(salt, address, answer) [salt 是他们选择的一些数字]，合约存储了这个散列和发件人的地址。为了索取奖励，发件人然后提交与salt的交易，并回答。合约散列（salt、msg.sender、answer）并根据存储的散列检查产生的散列，如果散列与合约匹配则释放奖励。

ERC20 竞态条件的最佳解决方案是在approve的输入中添加一个字段，该字段是预期的当前值，如果 Eve 的当前配额不是 Alice 表示的预期值，则approve revert。然而，这意味着您的合约不再符合 ERC20 标准。如果合约符合 ERC20 对您的项目很重要，您可以添加安全批准功能。从用户的角度来看，可以通过在更改approve之前将approve设置为零来调解 ERC20 竞争条件 。

#### References
- [General Article on Race Conditions](https://medium.com/coinmonks/solidity-transaction-ordering-attacks-1193a014884e)
- [ERC20 Race Condition](https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/edit#)


### Contract Samples
#### ERC20.sol
```
pragma solidity ^0.4.24;

/** Taken from the OpenZeppelin github
 * @title SafeMath
 * @dev Math operations with safety checks that revert on error
 */
library SafeMath {

  /**
  * @dev Multiplies two numbers, reverts on overflow.
  */
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
    // benefit is lost if 'b' is also tested.
    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
    if (a == 0) {
      return 0;
    }

    uint256 c = a * b;
    require(c / a == b);

    return c;
  }

  /**
  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.
  */
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    require(b > 0); // Solidity only automatically asserts when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold

    return c;
  }

  /**
  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).
  */
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    require(b <= a);
    uint256 c = a - b;

    return c;
  }

  /**
  * @dev Adds two numbers, reverts on overflow.
  */
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    require(c >= a);

    return c;
  }

  /**
  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),
  * reverts when dividing by zero.
  */
  function mod(uint256 a, uint256 b) internal pure returns (uint256) {
    require(b != 0);
    return a % b;
  }
}


contract ERC20 {

  event Transfer( address indexed from, address indexed to, uint256 value );
  event Approval( address indexed owner, address indexed spender, uint256 value);
  using SafeMath for *;

  mapping (address => uint256) private _balances;

  mapping (address => mapping (address => uint256)) private _allowed;

  uint256 private _totalSupply;

  constructor(uint totalSupply){
    _balances[msg.sender] = totalSupply;
  }

  function balanceOf(address owner) public view returns (uint256) {
    return _balances[owner];
  }


  function allowance(address owner, address spender) public view returns (uint256)
  {
    return _allowed[owner][spender];
  }

  function transfer(address to, uint256 value) public returns (bool) {
    require(value <= _balances[msg.sender]);
    require(to != address(0));

    _balances[msg.sender] = _balances[msg.sender].sub(value);
    _balances[to] = _balances[to].add(value);
    emit Transfer(msg.sender, to, value);
    return true;
  }

  function approve(address spender, uint256 value) public returns (bool) {
    require(spender != address(0));

    _allowed[msg.sender][spender] = value;
    emit Approval(msg.sender, spender, value);
    return true;
  }

  function transferFrom(address from, address to, uint256 value) public returns (bool) {
    require(value <= _balances[from]);
    require(value <= _allowed[from][msg.sender]);
    require(to != address(0));

    _balances[from] = _balances[from].sub(value);
    _balances[to] = _balances[to].add(value);
    _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);
    emit Transfer(from, to, value);
    return true;
  }
}
```
**问题描述：**
approve方法在被transfer抢先执行的情况下，会导致授权者损失代币

**问题描述：**
如果只是想改变allowed的amount，请使用increaseAllowance/decreaseAllowance。或者先试用approve设置被授权者的allowed为0。

#### eth_tx_order_dependence_minimal.sol
```
/*
 * @source: https://github.com/ConsenSys/evm-analyzer-benchmark-suite
 * @author: Suhabe Bugrara
 */

pragma solidity ^0.4.16;

contract EthTxOrderDependenceMinimal {
    address public owner;
    bool public claimed;
    uint public reward;

    function EthTxOrderDependenceMinimal() public {
        owner = msg.sender;
    }

    function setReward() public payable {
        require (!claimed);

        require(msg.sender == owner);
        owner.transfer(reward);
        reward = msg.value;
    }

    function claimReward(uint256 submission) {
        require (!claimed);
        require(submission < 10);

        msg.sender.transfer(reward);
        claimed = true;
    }
}
```
问题描述：
setReward/claimReward都可以抢先运行，导致setReward/claimReward不是执行者预期的执行逻辑
